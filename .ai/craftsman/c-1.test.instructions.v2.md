# Craftsman: Instrucciones para Testing de Aplicaciones Django REST Framework

## Rol

Actúa como _ingeniero de calidad senior_ para generar **tests completos y de alta calidad** siguiendo las mejores prácticas establecidas en el proyecto, asegurando cobertura exhaustiva y mantenibilidad.

---

## Arquitectura del Proyecto

Este proyecto sigue una **arquitectura de 3 capas**:

```
Request → View → Service → Repository → Database
Response ← View ← Service ← Repository ← Database
```

**Reglas de Dependencia**:
- Views dependen de Services
- Services dependen de Repositories
- Repositories interactúan con Models/ORM
- **NUNCA** invertir estas dependencias
- Solo un nivel de dependencias (no saltarse capas)

**Implicaciones para Testing**:
- Tests de **Models**: Verifican estructura, validaciones y constraints
- Tests de **Repositories**: Verifican queries, filtros y operaciones de BD
- Tests de **Services**: Usan mocks de repositories, verifican lógica de negocio
- Tests de **Serializers**: Verifican validación y transformación de datos
- Tests de **Views**: Verifican endpoints, autenticación y respuestas HTTP

---

## Proceso de Testing

### 1. Análisis Previo

Antes de escribir tests:

1. **Lee el código implementado** en orden:
   - `models.py` - Estructura de datos y validaciones
   - `repositories.py` - Operaciones de base de datos
   - `services.py` - Lógica de negocio
   - `serializers.py` - Validación y transformación
   - `views.py` - Endpoints HTTP
   - `urls.py` - Rutas y nombres

2. **Identifica dependencias**:
   - Modelos relacionados (ForeignKey, ManyToMany)
   - Servicios externos
   - Permisos y autenticación requeridos

3. **Revisa factories existentes**:
   - Verifica en `apps/*/factories.py`
   - Usa factories existentes siempre que sea posible
   - Crea nuevos factories si es necesario

---

## Estructura de Tests

### Archivo de Tests

**Ubicación**: `apps/<app_name>/tests.py`

**Estructura del archivo**:

```python
from __future__ import annotations

from typing import TYPE_CHECKING

from django.test import TestCase
from django.core.exceptions import ValidationError
from django.contrib.auth import get_user_model
from django.urls import reverse
from rest_framework.test import APIClient
from rest_framework import status
from unittest.mock import patch, MagicMock

from apps.<app_name>.models import Model1, Model2
from apps.<app_name>.services import service1, service2
from apps.<app_name>.repositories import repository1, repository2
from apps.<app_name>.serializers import Serializer1, Serializer2

if TYPE_CHECKING:
    from apps.users.models import User

User = get_user_model()


# ============================================================================
# Tests de Modelos
# ============================================================================


class Model1TestCase(TestCase):
    """Tests para el modelo Model1."""
    
    @classmethod
    def setUpTestData(cls) -> None:
        """Crea datos una sola vez para toda la clase de test."""
        cls.user = User.objects.create_user(...)
        cls.related_model = RelatedModel.objects.create(...)
    
    def test_model_creation_success(self) -> None:
        """Test: Crear modelo exitosamente."""
        # Arrange
        data = {...}
        
        # Act
        instance = Model1.objects.create(**data)
        
        # Assert
        with self.subTest("Verificar campo1"):
            self.assertEqual(instance.campo1, expected_value)
        
        with self.subTest("Verificar timestamps"):
            self.assertIsNotNone(instance.created_at)


# ============================================================================
# Tests de Repositorios
# ============================================================================


class Model1RepositoryTestCase(TestCase):
    """Tests para operaciones de repositorio de Model1."""
    
    @classmethod
    def setUpTestData(cls) -> None:
        """Crea datos una sola vez para toda la clase de test."""
        cls.user = User.objects.create_user(...)
        # ... setup compartido


# ============================================================================
# Tests de Servicios (con mocks)
# ============================================================================


class Model1ServiceTestCase(TestCase):
    """Tests para servicios de Model1 con mocks."""
    
    def setUp(self) -> None:
        """Arrange: Configura datos de prueba."""
        self.user = User.objects.create_user(...)
    
    @patch("apps.<app_name>.services.repository_function")
    def test_service_function_success(self, mock_repo: MagicMock) -> None:
        """Test: Servicio ejecuta exitosamente."""
        # Arrange
        mock_instance = Model1(field=value)
        mock_instance.id = 1  # Simular ID sin guardar en BD
        mock_repo.return_value = mock_instance
        
        # Act
        result = service_function(params)
        
        # Assert
        self.assertEqual(result.field, expected_value)
        mock_repo.assert_called_once_with(expected_params)


# ============================================================================
# Tests de Serializadores
# ============================================================================


class Model1SerializerTestCase(TestCase):
    """Tests para serializadores de Model1."""


# ============================================================================
# Tests de API Views
# ============================================================================


class Model1ListAPIViewTestCase(TestCase):
    """Tests para Model1ListAPIView."""
    
    def setUp(self) -> None:
        """Arrange: Configura datos de prueba."""
        self.client = APIClient()
        self.user = User.objects.create_user(...)
        self.client.force_authenticate(user=self.user)


# ============================================================================
# Tests de Cascade Delete
# ============================================================================


class CascadeDeleteTestCase(TestCase):
    """Tests para verificar relaciones CASCADE."""


# ============================================================================
# Tests de Integración End-to-End
# ============================================================================


class Model1IntegrationE2ETestCase(TestCase):
    """Tests E2E que verifican flujos completos."""
```

---

## Mejoras Obligatorias

### Mejora 1: Usar Factories (Factory Pattern)

**Siempre usar factories para crear objetos de test cuando existan.**

```python
# ❌ MAL - Crear objetos manualmente
user = User.objects.create_user(username="test", email="test@example.com")
model = Model.objects.create(name="Test", user=user)

# ✅ BIEN - Usar factories
from apps.users.factories import UserFactory
from apps.<app_name>.factories import ModelFactory

user = UserFactory()
model = ModelFactory(user=user)
```

**Crear factories para modelos nuevos**:

```python
# apps/<app_name>/factories.py
import factory
from factory.django import DjangoModelFactory
from apps.<app_name>.models import Model1


class Model1Factory(DjangoModelFactory):
    class Meta:
        model = Model1
    
    name = factory.Faker("name")
    description = factory.Faker("text")
    user = factory.SubFactory("apps.users.factories.UserFactory")
```

### Mejora 2: Usar setUpTestData() para Performance

**Usar `@classmethod setUpTestData()` en lugar de `setUp()` cuando los datos sean inmutables.**

```python
# ❌ MAL - setUp() crea datos en cada test
def setUp(self) -> None:
    self.user = User.objects.create_user(...)
    self.model = Model.objects.create(...)

# ✅ BIEN - setUpTestData() crea datos una vez
@classmethod
def setUpTestData(cls) -> None:
    """Crea datos una sola vez para toda la clase de test."""
    cls.user = User.objects.create_user(...)
    cls.model = Model.objects.create(...)
```

**Cuándo usar cada uno**:
- `setUpTestData()`: Para datos que NO se modifican en los tests (solo lectura)
- `setUp()`: Para datos que SÍ se modifican en cada test

### Mejora 3: Usar Mocks Correctamente en Tests de Servicios

**Los tests de servicios deben mockear repositories, NO crear objetos reales en BD.**

```python
# ❌ MAL - Crear objetos reales en BD en tests de servicio
@patch("apps.routines.services.create_routine_repository")
def test_create_routine_service(self, mock_repo: MagicMock) -> None:
    routine = Routine.objects.create(name="Test", created_by=self.user)  # ❌
    mock_repo.return_value = routine

# ✅ BIEN - Usar objetos mock sin guardar
@patch("apps.routines.services.create_routine_repository")
def test_create_routine_service(self, mock_repo: MagicMock) -> None:
    routine = Routine(name="Test", created_by=self.user)  # Sin .create()
    routine.id = 1  # Simular ID manualmente
    mock_repo.return_value = routine
```

### Mejora 4: Tests Completos de CRUD

**Cada operación de servicio debe tener tests para todos los casos:**

```python
# Para cada operación (create, update, delete):
def test_{operation}_{entity}_service_success(self) -> None:
    """Test: Operación exitosa."""

def test_{operation}_{entity}_service_not_found(self) -> None:
    """Test: Entidad no encontrada."""

def test_{operation}_{entity}_service_permission_denied(self) -> None:
    """Test: Sin permisos."""

def test_{operation}_{entity}_service_validation_error(self) -> None:
    """Test: Error de validación."""
```

### Mejora 5: Usar reverse() para URLs

**NUNCA usar URLs hardcodeadas, siempre usar `reverse()`.**

```python
# ❌ MAL - URL hardcodeada
response = self.client.get("/api/routines/")
response = self.client.get(f"/api/routines/{routine.id}/")

# ✅ BIEN - Usar reverse()
from django.urls import reverse

response = self.client.get(reverse("routines_api:routine-list"))
response = self.client.get(reverse("routines_api:routine-detail", kwargs={"pk": routine.id}))
```

**Formato de nombres de URL**:
- Namespace: `<app_name>_api`
- Nombres: `<model>-list`, `<model>-detail`, `<model>-create`, etc.

### Mejora 6: Tests de Casos de Error en Repositorios

**Agregar tests para edge cases y validaciones:**

```python
def test_update_model_repository_partial_update(self) -> None:
    """Test: Actualización parcial no debe eliminar datos."""
    # Arrange
    instance = Model.objects.create(field1="A", field2="B", field3="C")
    validated_data = {"field1": "Updated"}  # Solo actualizar field1
    
    # Act
    updated = update_model_repository(instance=instance, validated_data=validated_data)
    
    # Assert
    self.assertEqual(updated.field1, "Updated")
    self.assertEqual(updated.field2, "B")  # No debe cambiar
    self.assertEqual(updated.field3, "C")  # No debe cambiar

def test_create_model_repository_duplicate_constraint(self) -> None:
    """Test: Crear con constraint duplicado lanza ValidationError."""
    # Arrange
    Model.objects.create(unique_field="value")
    validated_data = {"unique_field": "value"}
    
    # Act & Assert
    with self.assertRaises(ValidationError):
        create_model_repository(validated_data=validated_data)
```

### Mejora 7: Tests de Integración E2E

**Agregar tests que verifiquen flujos completos desde API hasta BD:**

```python
def test_e2e_create_complete_hierarchy(self) -> None:
    """Test E2E: Crear jerarquía completa de recursos."""
    # Step 1: Crear recurso principal
    parent_data = {"name": "Parent"}
    parent_response = self.client.post(
        reverse("app_api:parent-list"), parent_data, format="json"
    )
    self.assertEqual(parent_response.status_code, status.HTTP_201_CREATED)
    parent_id = parent_response.data["data"]["id"]
    
    # Step 2: Crear recurso hijo
    child_data = {"name": "Child", "parentId": parent_id}
    child_response = self.client.post(
        reverse("app_api:child-create", kwargs={"parent_id": parent_id}),
        child_data,
        format="json"
    )
    self.assertEqual(child_response.status_code, status.HTTP_201_CREATED)
    
    # Step 3: Verificar en BD
    parent = Parent.objects.get(id=parent_id)
    self.assertEqual(parent.children.count(), 1)
    
    # Step 4: Verificar GET detalle
    detail_response = self.client.get(
        reverse("app_api:parent-detail", kwargs={"pk": parent_id}) + "?full=true"
    )
    self.assertEqual(detail_response.status_code, status.HTTP_200_OK)
    self.assertEqual(len(detail_response.data["data"]["children"]), 1)
```

### Mejora 8: Tests de Cascade Delete

**Verificar que las relaciones CASCADE funcionan correctamente:**

```python
def test_delete_parent_cascades_to_children(self) -> None:
    """Test: Eliminar parent elimina children en cascada."""
    # Arrange
    parent = Parent.objects.create(name="Parent")
    child = Child.objects.create(parent=parent, name="Child")
    grandchild = Grandchild.objects.create(child=child, name="Grandchild")
    
    parent_id = parent.id
    child_id = child.id
    grandchild_id = grandchild.id
    
    # Act
    parent.delete()
    
    # Assert
    with self.subTest("Parent eliminado"):
        self.assertFalse(Parent.objects.filter(id=parent_id).exists())
    
    with self.subTest("Child eliminado en cascada"):
        self.assertFalse(Child.objects.filter(id=child_id).exists())
    
    with self.subTest("Grandchild eliminado en cascada"):
        self.assertFalse(Grandchild.objects.filter(id=grandchild_id).exists())
```

### Mejora 9: Usar SubTests para Múltiples Aserciones

**Usar `self.subTest()` para identificar exactamente qué aserción falla:**

```python
# ❌ MAL - Si falla, no sabes cuál específicamente falló
def test_model_serializer_success(self) -> None:
    serializer = ModelSerializer(self.model)
    data = serializer.data
    
    self.assertEqual(data["id"], self.model.id)
    self.assertEqual(data["name"], "Test")
    self.assertEqual(data["description"], "Description")

# ✅ BIEN - Cada aserción en un subtest con descripción
def test_model_serializer_success(self) -> None:
    serializer = ModelSerializer(self.model)
    data = serializer.data
    
    with self.subTest("Verificar id"):
        self.assertEqual(data["id"], self.model.id)
    
    with self.subTest("Verificar name"):
        self.assertEqual(data["name"], "Test")
    
    with self.subTest("Verificar description"):
        self.assertEqual(data["description"], "Description")
```

### Mejora 10: Tests de Permisos y Autenticación

**Cada endpoint debe tener tests de permisos:**

```python
def test_create_model_post_success(self) -> None:
    """Test: POST crear modelo exitosamente."""
    # ... test normal

def test_create_model_post_permission_denied(self) -> None:
    """Test: POST crear modelo de otro usuario."""
    # Arrange
    other_user = User.objects.create_user(username="other", email="other@example.com")
    other_parent = Parent.objects.create(created_by=other_user)
    data = {"name": "Test"}
    
    # Act
    response = self.client.post(
        reverse("app_api:model-create", kwargs={"parent_id": other_parent.id}),
        data,
        format="json"
    )
    
    # Assert
    self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN)
    self.assertIn("error", response.data)

def test_create_model_post_unauthenticated(self) -> None:
    """Test: POST crear modelo sin autenticación."""
    # Arrange
    self.client.force_authenticate(user=None)
    data = {"name": "Test"}
    
    # Act
    response = self.client.post(
        reverse("app_api:model-create", kwargs={"parent_id": self.parent.id}),
        data,
        format="json"
    )
    
    # Assert
    self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
```

---

## Convenciones de Nomenclatura

### Nombres de Tests

**Formato general**: `test_{action}_{entity}_{condition}_{expected_result}`

**Por tipo de test**:

```python
# Tests de Modelos
test_{model}_creation_success
test_{model}_str_representation
test_{model}_validation_{field}_invalid
test_{model}_unique_constraint
test_{model}_ordering

# Tests de Repositorios
test_create_{entity}_repository_success
test_get_{entity}_by_id_repository_not_found
test_list_{entities}_repository_with_filters
test_update_{entity}_repository_partial_update
test_delete_{entity}_repository_success

# Tests de Servicios
test_{action}_{entity}_service_success
test_{action}_{entity}_service_not_found
test_{action}_{entity}_service_permission_denied
test_{action}_{entity}_service_validation_error

# Tests de Serializadores
test_{model}_serializer_success
test_{model}_create_serializer_valid_data
test_{model}_create_serializer_invalid_{field}
test_{model}_update_serializer_partial_update

# Tests de API
test_{http_method}_{endpoint}_success
test_{http_method}_{endpoint}_permission_denied
test_{http_method}_{endpoint}_unauthenticated
test_{http_method}_{endpoint}_invalid_data
test_{http_method}_{endpoint}_not_found

# Tests E2E
test_e2e_create_complete_{resource}_hierarchy
test_e2e_soft_delete_preserves_hierarchy
test_e2e_{flow_name}_complete_flow

# Tests de Cascade Delete
test_delete_{parent}_cascades_to_{children}
test_delete_{entity}_with_multiple_{relations}
```

### Nombres de Clases de Test

**Formato**: `{Entity}{Type}TestCase`

```python
# Modelos
class RoutineModelTestCase(TestCase):
class WeekModelTestCase(TestCase):

# Repositorios
class RoutineRepositoryTestCase(TestCase):
class WeekRepositoryTestCase(TestCase):

# Servicios
class RoutineServiceTestCase(TestCase):
class WeekServiceTestCase(TestCase):

# Serializadores
class RoutineSerializerTestCase(TestCase):
class WeekSerializerTestCase(TestCase):

# API Views
class RoutineListAPIViewTestCase(TestCase):
class RoutineDetailAPIViewTestCase(TestCase):
class WeekCreateAPIViewTestCase(TestCase):

# Tests especiales
class CascadeDeleteTestCase(TestCase):
class RoutineIntegrationE2ETestCase(TestCase):
```

---

## Patrón Arrange-Act-Assert (AAA)

**Todos los tests DEBEN seguir este patrón:**

```python
def test_example(self) -> None:
    """Test: Descripción clara del test."""
    # Arrange: Configura estado inicial
    user = User.objects.create_user(username="test", email="test@example.com")
    data = {"name": "Test", "user": user}
    
    # Act: Ejecuta la acción a probar
    result = function_under_test(data)
    
    # Assert: Verifica el resultado esperado
    self.assertEqual(result.name, "Test")
    self.assertEqual(result.user, user)
```

**Usar comentarios para marcar las secciones**:
- `# Arrange` o `# Arrange: Descripción`
- `# Act` o `# Act: Descripción`
- `# Assert` o `# Assert: Descripción`

---

## Importaciones y Type Hints

**Estructura de importaciones**:

```python
from __future__ import annotations

from typing import TYPE_CHECKING

# Standard library
import os
from datetime import datetime

# Django
from django.test import TestCase
from django.core.exceptions import ValidationError
from django.contrib.auth import get_user_model
from django.urls import reverse

# Django REST Framework
from rest_framework.test import APIClient
from rest_framework import status

# Third party
from unittest.mock import patch, MagicMock

# Local imports
from apps.<app_name>.models import Model1, Model2
from apps.<app_name>.services import service1, service2
from apps.<app_name>.repositories import repository1, repository2

# Type checking imports
if TYPE_CHECKING:
    from apps.users.models import User
    from apps.other_app.models import OtherModel

User = get_user_model()
```

**Type hints obligatorios**:
- En definiciones de funciones de test: `def test_example(self) -> None:`
- En setUp/setUpTestData: `def setUp(self) -> None:`
- En variables cuando no sean obvias

---

## Checklist de Calidad

Antes de completar, verifica:

### Estructura y Organización
- [ ] Tests organizados por tipo (Models, Repositories, Services, etc.)
- [ ] Secciones separadas con comentarios `# ============`
- [ ] Importaciones correctamente organizadas
- [ ] Type hints en todas las funciones

### Performance
- [ ] Usar `@classmethod setUpTestData()` para datos inmutables
- [ ] Tests ejecutan en <1 segundo cada uno
- [ ] Total de tests ejecuta en tiempo razonable (<30-60s para 100-200 tests)

### Cobertura
- [ ] Tests de modelos: creation, str, validation, constraints, ordering
- [ ] Tests de repositorios: CRUD completo, filtros, edge cases
- [ ] Tests de servicios: success, not_found, permission_denied, validation_error
- [ ] Tests de serializadores: valid data, invalid data, transformación
- [ ] Tests de API: success, permission_denied, unauthenticated, invalid_data
- [ ] Tests de cascade delete cuando aplique
- [ ] Al menos 1 test E2E de flujo completo

### Calidad de Tests
- [ ] Todos los tests siguen patrón Arrange-Act-Assert
- [ ] Nombres descriptivos y consistentes con convenciones
- [ ] SubTests usados para múltiples aserciones relacionadas
- [ ] Mocks usados correctamente en tests de servicios
- [ ] URLs usando `reverse()`, nunca hardcodeadas
- [ ] Factories usados en lugar de crear objetos manualmente

### Ejecución
- [ ] Todos los tests pasan: `docker compose run --rm web python manage.py test apps.<app_name>`
- [ ] Sin warnings de deprecación
- [ ] Tests independientes (pueden ejecutarse en cualquier orden)
- [ ] Sin efectos secundarios entre tests

### Documentación
- [ ] Cada clase de test tiene docstring descriptivo
- [ ] Cada método de test tiene docstring con "Test: Descripción"
- [ ] Comentarios AAA claros en cada test

---

## Comandos de Ejecución

```bash
# Ejecutar todos los tests de una app
docker compose run --rm web python manage.py test apps.<app_name>

# Ejecutar una clase de test específica
docker compose run --rm web python manage.py test apps.<app_name>.tests.ModelTestCase

# Ejecutar un test específico
docker compose run --rm web python manage.py test apps.<app_name>.tests.ModelTestCase.test_specific

# Con verbosidad
docker compose run --rm web python manage.py test apps.<app_name> -v 2

# Con cobertura
docker compose run --rm web coverage run --source='apps' manage.py test apps.<app_name>
docker compose run --rm web coverage report
docker compose run --rm web coverage html  # Genera reporte HTML
```

---

## Ejemplo Completo

Ver `apps/routines/tests.py` como referencia de implementación completa con todas las mejoras aplicadas.

**Características clave del ejemplo**:
- 163 tests organizados en 19 clases
- Uso de `setUpTestData()` para mejor performance
- Mocks correctos en tests de servicios
- SubTests para aserciones múltiples
- Tests de cascade delete
- Tests E2E de flujos completos
- Tests de permisos para todos los endpoints
- Cobertura completa de CRUD

---

## Referencias

- Código de referencia: `apps/routines/tests.py`
- Guía de mejoras: `docs/testing-improvements-guide.md`
- Reglas de Django: `.cursor/rules/django-drf-api.rules.mdc`
- Reglas de Clean Code: `.cursor/rules/clean-code-django-python.mdc`
- Arquitectura: `docs/DOMAIN.md`
